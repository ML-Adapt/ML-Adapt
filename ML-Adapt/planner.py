SCALE_UP_TIME = {'adservice': [0, 0.0, 0], 'cartservice': [0, 0.0, 0], 'checkoutservice': [0, 0.0, 0],
                 'currencyservice': [0, 0.0, 0], 'emailservice': [0, 0.0, 0], 'frontend': [0, 0.0, 0],
                 'paymentservice': [0, 0.0, 0], 'productcatalogservice': [0, 0.0, 0],
                 'recommendationservice': [0, 0.0, 0], 'redis-cart': [0, 0.0, 0], 'shippingservice': [0, 0.0, 0]}

SCALE_DOWN_TIME = {'adservice': [0, 0.0, 0], 'cartservice': [0, 0.0, 0], 'checkoutservice': [0, 0.0, 0],
                   'currencyservice': [0, 0.0, 0], 'emailservice': [0, 0.0, 0], 'frontend': [0, 0.0, 0],
                   'paymentservice': [0, 0.0, 0], 'productcatalogservice': [0, 0.0, 0],
                   'recommendationservice': [0, 0.0, 0], 'redis-cart': [0, 0.0, 0], 'shippingservice': [0, 0.0, 0]}


def data_to_timestamp():
    from datetime import datetime
    now = datetime.now()
    timestamp = datetime.timestamp(now)

    return timestamp


def is_available(data, time_between_actions):
    last_scale_id = data[0]

    if last_scale_id == 1:
        timestamp = data[1]
        actual_timestamp = data_to_timestamp()
        time = actual_timestamp - timestamp

        if time < time_between_actions:
            return False

    return True


def update_and_collect_the_blocked_by_time(deployment, id_scale):
    if id_scale <= -1:
        if is_available(SCALE_DOWN_TIME[deployment], 300):  # Turn off Successive Adaptations Containment = 0
            SCALE_DOWN_TIME[deployment][0] = 0
            SCALE_DOWN_TIME[deployment][1] = 0.0

            return True
    elif id_scale >= 1:
        if is_available(SCALE_UP_TIME[deployment], 180):  # Turn off Successive Adaptations Containment = 0
            SCALE_UP_TIME[deployment][0] = 0
            SCALE_UP_TIME[deployment][1] = 0.0

            return True

    return False


def insert_in_the_blocked_by_time(deployment, id_scale):
    if id_scale <= -1:
        SCALE_DOWN_TIME[deployment][0] = 1
        SCALE_DOWN_TIME[deployment][1] = data_to_timestamp()
    elif id_scale >= 1:
        SCALE_UP_TIME[deployment][0] = 1
        SCALE_UP_TIME[deployment][1] = data_to_timestamp()


def insert_in_quarantine(deployment, id_scale):
    if id_scale <= -1:
        SCALE_DOWN_TIME[deployment][2] = SCALE_DOWN_TIME[deployment][2] + 1
    elif id_scale >= 1:
        SCALE_UP_TIME[deployment][2] = SCALE_UP_TIME[deployment][2] + 1


def search_in_quarantine(deployment, id_scale):
    if id_scale <= -1:
        return SCALE_DOWN_TIME[deployment][2]
    elif id_scale >= 1:
        return SCALE_UP_TIME[deployment][2]


def reset_in_quarantine(deployment, id_scale):
    if id_scale <= -1:
        SCALE_DOWN_TIME[deployment][2] = 0
    elif id_scale >= 1:
        SCALE_UP_TIME[deployment][2] = 0


def calc_desired_replicas(values_of_microservice):
    """Calculate the ideal number of replicates.
        Args:
            values_of_microservice (dict):  The proportion and the number of replicas of microservice.

        Returns:
            id_scale (int): Identification to plan adaptation;
            request_format (dict): Container Application Manager Request Format;
            current_replicas (int): Number current of replicas of microservice.
    """
    from math import ceil
    ratio = values_of_microservice[0]
    request_format = values_of_microservice[1]
    current_replicas = request_format['spec']['replicas']

    desired_replicas = ceil(current_replicas * ratio)
    if ratio < 0.9:
        id_scale = desired_replicas - current_replicas
        return id_scale, request_format, current_replicas
    elif ratio > 1.1:
        id_scale = desired_replicas - current_replicas
        return id_scale, request_format, current_replicas


def plan_adaptive_actions(analysis_report):
    """Plans a set of actions to be carried out in the execution phase to deal with problems in microservices.

        Args:
            analysis_report (dict): Set of information about the status of microservices
            generated by the Analyser.

        Returns:
            List containing actions to be performed on the executor

            For example: ['shippingservice', -1, 'Container Application Manager Request Format']
    """
    adaptation_plans = []
    for name_microservice, values_of_microservice in analysis_report.items():
        deployment = name_microservice
        id_scale, request_format, current_replicas = calc_desired_replicas(values_of_microservice)

        # Is the microservice blocked by the Successive Adaptations Containment?
        if update_and_collect_the_blocked_by_time(deployment, id_scale):  #
            if search_in_quarantine(deployment, id_scale) <= 1:  # Quarentine ON
                # if search_in_quarantine(deployment, id_scale) != 0: # Quarentine OFF
                insert_in_quarantine(deployment, id_scale)
                reset_in_quarantine(deployment, (id_scale * -1))
            else:
                new_replicas = current_replicas + id_scale
                if id_scale <= -1 and new_replicas >= 1:  # Is it possible to scaling-in?
                    insert_in_the_blocked_by_time(deployment, id_scale)
                    reset_in_quarantine(deployment, id_scale)
                    adaptation_plans.append([deployment, id_scale, request_format])
                elif id_scale >= 1 and current_replicas <= 10:  # Is it possible to scaling-out?
                    insert_in_the_blocked_by_time(deployment, id_scale)
                    reset_in_quarantine(deployment, id_scale)
                    adaptation_plans.append([deployment, id_scale, request_format])

    return adaptation_plans


class Planner:
    pass
